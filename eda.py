# -*- coding: utf-8 -*-
"""
Created on Tue Sep  1 09:13:28 2020

CODE FROM https://github.com/Ali-Alhamaly/Turbofan_usefull_life_prediction/blob/master/Jet_Engine_Remaining_Useful_Life_Prediction.ipynb

@author: mtbieber
"""

import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import importlib
#import plot_helper as plt_hlp
#importlib.reload(plt_hlp); # so that I can use plot_helper without reloading the notebook kernel each time 


datapath = 'data/'
figpath = 'figures/'
filename = 'train_FD001.txt'

filepath = ''.join((datapath, filename))

# column names for the dataset
# op_cond refers to operational condition, sn: sensor
col_name = ['engine', 'time', 'op_cond_1', 'op_cond_2', 'op_cond_3']
col_name = col_name + ['sn_{}'.format(s + 1) for s in range(21)]


# load data into sesnor df
# notice index_col=0 is used so that the data for each separate engine can be obtained easily
#(engine columns is just a group of data)
df = pd.read_csv(filepath, header=None, names=col_name,delim_whitespace=True,index_col=0)

df.info()
df.describe()

sns.set()
# look at the mean of all columns
df.mean().plot.bar(figsize=(12,8))

# mean for engine num=5
engine_num=5
df.loc[engine_num].mean().plot.bar(figsize=(12,8))

corr_all=df.drop('time',axis=1).corr()# linear correlation between variables for all engines
corr_num=df.loc[engine_num].drop('time',axis=1).corr() # linear correlation between variables for engine [engine_num]

sns.heatmap(corr_num, 
            xticklabels=corr_num.columns.values,
            yticklabels=corr_num.columns.values)




def find_corr_pairs(corr,thrsh):
    
    """
    find high correlation column pairs in df 
    ======================================
    input: 
    corr - (df)- correlation matrix generated by pandas
    thrsh - (float) threshold value to consider correlation as high so that it is included in the output 
    output:
    high_corr_pairs - (list) list of tuples of the two-column names and their correlation. corr> thrsh
    """
    high_corr_pairs = []
    # same as input 'corr' but the upper -triangle half of the matrix is zeros ( for convenience only) 
    corr_diag = pd.DataFrame(np.tril(corr.values), columns=corr.columns, index = corr.index)

    # check  the correlation between every pair of columns in the corr and keeps the high ones
    for col_num , col in enumerate(corr_diag):
        col_corr=corr_diag[col].iloc[col_num+1:] # this slicing ensures ignoring self_corr and duplicates due to symmetry
        # bool mask for pairs with high corr with col
        mask_pairs = col_corr.apply(lambda x: abs(x))>thrsh 
        idx_pairs=col_corr[mask_pairs].index

        # create list of high corr pairs
        for idx , corr in zip(idx_pairs,col_corr[mask_pairs].values):
            high_corr_pairs.append((col, idx, corr))
    
    return high_corr_pairs



corr_pairs=find_corr_pairs(corr_all,0.9)
for c in corr_pairs:
    print(c)
    


#VARIABLE DISTRIBUTION
def plot_dist(df, engine_num=None):
    '''plot all non trivial measurements and states'''
    
    cols = df.columns
    n_cols = min(len(cols), 5)
    n_rows = int(np.ceil(len(cols) / n_cols))
    
    sns.set()
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(15,12))
    axes = axes.flatten()
    if engine_num != None: 
        fig.suptitle('distributions for engine #: {}'.format(engine_num))
        df_plot = df.loc[engine_num]
    else: 
        fig.suptitle('distributions for all engines')
        df_plot = df
    for col, ax in zip(cols, axes):
        ax=sns.distplot(df_plot[col], ax=ax, label=col)
        ax.legend(loc=1)
    #         labels(col, "p", ax)
    return fig

fig=plot_dist(df)
fig.savefig(''.join((figpath, 'dist_all.png')), format='png', dpi=600)


#Remove cols that do not change with time
col_remove=[ col for col in df.columns if (df[col].std() <= .0001*df[col].mean()) & (df[col].nunique() <=4)  ]

print('columns to be removed from analysis since they do not change with time \n',col_remove)
df.drop(columns=col_remove,axis=1,inplace=True)


#Correlations now again
engine_num=17
thrsh=.9
corr_all=df.drop('time',axis=1).corr()# linear correlation between variables for all engines
corr_num=df.loc[engine_num].drop('time',axis=1).corr() # linear correlation between variables for engine [engine_num]

corr_pairs=find_corr_pairs(corr_all,thrsh)
print('high correlation columns all engines:')
for c in corr_pairs:
    print(c)
    
corr_pairs=find_corr_pairs(corr_num,thrsh)
print('high correlation columns engine # {}:'.format(engine_num))
for c in corr_pairs:
    print(c)    



#pairplot
def plot_pair(df,idx1,idx2,engine_num=None):
    """
    plot simple pair plots for a df between columns [idx1,idx2]
    ===========================================================
    input: 
    df - (df)- Dataframe to plot the pairs for 
    idx1,2 - (int) columns index to plot [idx1:idx2] 
    engine_num - (int) engine number to selector 
    """  
    sns.set()
    cols = df.iloc[:,idx1:idx2].columns.values.tolist()
    
    if engine_num == None: 
        df_pair_plot = df.iloc[:,idx1:idx2]
        print('plotting pairs for all engines and columns: {}'.format(cols))
        sns.pairplot(df_pair_plot,diag_kind = 'kde',height=2.5);
    else:
        df_pair_plot = df.loc[engine_num].iloc[:,idx1:idx2]
        sns.pairplot(df_pair_plot,diag_kind = 'kde',height=2.5);
        print('plotting pairs for engine {} and columns: {}'.format(engine_num,cols))
        
idx1 = 6
idx2 = 10
plot_pair(df,idx1,idx2)

idx1 = 1
idx2 = 5
engine_num = 5
plot_pair(df,idx1,idx2,engine_num)


#Plot timeseries
def plot_ts(df, engine_num=1):
    """
    plot time history of for specific engine 
    ========================================
    input: 
    df - (df) Dataframe you whish to plot the time series for its columns
    engine_num - (int) engine number to selector  
    """
    
    # prepare the dataframe for plotting
    ts = df.loc[engine_num].copy() # df for the needed engine
    time = ts['time']
    ts.drop(labels=['time'],axis=1,inplace=True)
    cols = ts.columns
    
    # plotting
    fig, axes = plt.subplots(len(cols), 1, figsize=(19,17))
    for col, ax in zip(cols, axes):
        ax.plot(time,ts[col],label=col)
        ax.legend(loc=2)
        
    # figure title    
    fig.suptitle('Engine #: {}'.format(engine_num))
                 

plot_ts(df, 99)




# =============================================================================
# ADD RUL
# =============================================================================
# add RUL to each engine based on time column, 
# notice that RUL is negative quantity here to make 0 as the end of life for all engines
for id in df.index.unique():
    df.loc[id,'RUL'] = df.loc[id]['time'].apply(lambda x: x-df.loc[id]['time'].max())
    
def plot_ts_all(df):
    """
    plot time history of for all engines in the data
    =================================================
    input: 
    df - (df) Dataframe you whish to plot the time series for its columns
    """
    
    # prepare the dataframe for plotting
    ts = df.copy() # df for the needed engine
    ts.drop(labels=['time'],axis=1,inplace=True)
    
    cols = ts.columns
    # plotting
    fig, axes = plt.subplots(len(cols)-1, 1, figsize=(19,17))
    for col, ax in zip(cols, axes):
        if col == 'RUL':
            continue
            
        fontdict = {'fontsize': 14}
        ax.set_title(col,loc='left',fontdict=fontdict)
        for engine_id in ts.index.unique():
            time = ts.loc[engine_id,'RUL']
            ax.plot(time,ts.loc[engine_id,col],label=col)
            
        
        
    # figure title    
    fig.suptitle('All Engines Time Series \n each line is different engine resposne\n x-axis is RUL with the rightmost point\
    being the last cycle for all engines')
    return fig

fig=plot_ts_all(df)
fig.savefig(''.join((figpath, 'ts_all.png')), format='png', dpi=600)


'''
From the time series plot of all engine, we can find the below takeaways

- columns [op_cond_1, op_cond_2] do not have an apparent trend towards the end life of the engine. they are just random noise. so with great confidence, we can say that these two columns cannot help a predicitive model that is based on the trend of the series to discover relevant information regarding estimating the RUL
- columns [sn_9 , sn_14] indicate that the trend depends on the specific engine. some engines at the end of life tend to increase in these two columns while others tend to decrease. what is common about these two sensors is that the magnitude at the end life gets amplified.
- note that all other columns show an apparent trend as the fault propagate throughout the engine cycles and cause them to fail. [ this helps the model that will try to use the data to predict RUL :) ]

'''
